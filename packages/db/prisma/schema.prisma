generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
}

model Admin {
  id                String             @id @default(cuid())
  email             String             @unique
  name              String
  password          String
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  subscriptionPlans SubscriptionPlan[]
}

model User {
  id            String                @id @default(cuid())
  firebaseUid   String                @unique
  email         String                @unique
  name          String?
  planId        String?
  plan          SubscriptionPlan?     @relation(fields: [planId], references: [id])
  folders       Folder[]
  files         File[]
  transactions  Transaction[]
  storageUsed   BigInt                @default(0) // in bytes
  createdAt     DateTime              @default(now())
  updatedAt     DateTime              @updatedAt
  subscriptions SubscriptionHistory[]

  @@map("users")
}

model Folder {
  id             String   @id @default(cuid())
  name           String
  owner          User     @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId        String
  parentFolderId String?
  parentFolder   Folder?  @relation("SubFolders", fields: [parentFolderId], references: [id], onDelete: Cascade)
  subFolders     Folder[] @relation("SubFolders")
  files          File[]   @relation("FileFolder")
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@index([ownerId])
  @@index([parentFolderId])
  @@map("folders")
}

model File {
  id       String @id @default(cuid())
  filename String

  access   FileAccess @default(PUBLIC)
  size     BigInt
  fileType FileType
  owner    User       @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId  String
  folder   Folder?    @relation("FileFolder", fields: [folderId], references: [id], onDelete: SetNull) // Change onDelete
  folderId String? //  Optional when file is in trash
  mimeType String

  // cloud metadata
  storageKey String  @unique
  // bucket and region are optional for cloud migration in future
  bucket     String?
  region     String?

  // Upload related fields
  uploadStrategy UploadStrategy @default(SINGLE_PART)
  uploadStatus   FileStatus     @default(INITIATED)
  uploadId       String?

  uploadedAt DateTime @default(now())
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // flag that indicates if the file is in trash or not
  isInTrash Boolean @default(false)

  // Metadata for restoration
  originalFolderId String? // Where to restore the file
  deletedAt        DateTime? // When it was deleted

  @@index([folderId])
  @@index([ownerId, isInTrash])
  @@index([uploadedAt])
  @@map("files")
}

model SubscriptionPlan {
  id                  String                @id @default(cuid())
  planType            Plan                  @default(FREE)
  price               Int                   @default(0)
  storageLimit        BigInt                @default(1073741824) // in bytes
  features            String[]              @default([]) // List of features included in the plan
  // durationInDays     Int                   @default(30) // Duration of the plan in days
  createdAt           DateTime              @default(now())
  updatedAt           DateTime              @updatedAt
  users               User[]
  subscriptionHistory SubscriptionHistory[]
  createdBy           Admin                 @relation(fields: [adminId], references: [id])
  adminId             String

  @@map("subscription_plans")
}

model SubscriptionHistory {
  id            String           @id @default(cuid())
  userId        String
  user          User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  planId        String
  plan          SubscriptionPlan @relation(fields: [planId], references: [id])
  startDate     DateTime         @default(now())
  endDate       DateTime?
  transactionId String?          @unique
  transaction   Transaction?     @relation("TransactionToSubscription", fields: [transactionId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([planId])
  @@index([startDate])
  @@map("subscription_history")
}

model Transaction {
  id                  String               @id @default(cuid())
  price               Int
  subscriptionHistory SubscriptionHistory? @relation("TransactionToSubscription")
  ownerId             String
  owner               User                 @relation(fields: [ownerId], references: [id])
  status              TransactionStatus    @default(PENDING)

  razorpayOrderId   String?  @unique
  razorpayPaymentId String?  @unique
  razorpaySignature String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@index([createdAt])
  @@index([ownerId])
  @@map("transactions")
}

enum FileType {
  IMAGE
  VIDEO
  AUDIO
  DOCUMENT
  ARCHIVE
  OTHER
}

enum Plan {
  FREE
  PRO
  ENTERPRISE
}

enum TransactionStatus {
  PENDING
  SUCCESS
  FAILED
  REFUNDED
}

enum FileAccess {
  PUBLIC
  PRIVATE
}

enum UploadStrategy {
  SINGLE_PART
  MULTI_PART
}

enum FileStatus {
  INITIATED
  COMPLETED
  FAILED
}
